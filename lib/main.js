// Generated by CoffeeScript 1.11.1
(function() {
  var $, $async, CND, D, LTSORT, PATH, alert, badge, debug, get_monotimestamp, help, log, rpr, step, urge, warn, whisper,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'TOPOCACHE/MAIN';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  alert = CND.get_logger('alert', badge);

  whisper = CND.get_logger('whisper', badge);

  LTSORT = require('ltsort');

  PATH = require('path');

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  step = require('coffeenode-suspend').step;

  this.HELPERS = require('./helpers');

  this.MONITORS = require('./monitors');

  this.ALIGNERS = require('./aligners');

  get_monotimestamp = require('./monotimestamp');

  this.new_cache = function(settings) {
    var R, aligners, home, monitors, ref, ref1, ref2;
    if (settings == null) {
      settings = null;
    }
    home = (ref = settings != null ? settings['home'] : void 0) != null ? ref : process.cwd();
    monitors = Object.assign({}, this.MONITORS, (ref1 = settings != null ? settings['monitors'] : void 0) != null ? ref1 : null);
    aligners = Object.assign({}, this.ALIGNERS, (ref2 = settings != null ? settings['aligners'] : void 0) != null ? ref2 : null);
    R = {
      '~isa': 'TOPOCACHE/cache',
      'graph': LTSORT.new_graph({
        loners: false
      }),
      'home': home,
      'fixes': {},
      'aligners': aligners,
      'monitors': monitors,
      'store': {}
    };
    return R;
  };

  this._is_fresh = function(me) {
    return me['graph']['precedents'].size === 0;
  };

  this._now = function() {
    return get_monotimestamp();
  };

  this.set = function(me, key, value, t0) {
    if (t0 == null) {
      t0 = null;
    }
    if (t0 == null) {
      t0 = this._now();
    }
    me['store'][key] = {
      t0: t0,
      key: key,
      value: value
    };
    return value;
  };

  this.get = function(me, key) {
    var ref;
    return (ref = me['store'][key]) != null ? ref['value'] : void 0;
  };

  this["delete"] = function(me, key) {
    return delete me['store'][key];
  };

  this.get_cache_entry = function(me, key) {
    return me['store'][key];
  };

  this.register_change = function(me, key, t0) {
    if (t0 == null) {
      t0 = null;
    }
    if (t0 == null) {
      t0 = this._now();
    }
    me['store'][key] = {
      t0: t0,
      key: key
    };
    return null;
  };

  this.validate_key = function(me, role, key) {
    this._split_key(me, role, key);
    return null;
  };

  this.split_key = function(me, key) {
    return this._split_key(me, null, key);
  };

  this._split_key = function(me, role, key) {
    var R, path, protocol, type;
    if ((type = CND.type_of(key)) !== 'text') {
      throw new Error("expected a text, got a " + type);
    }
    if ((R = key.split('::')).length !== 2) {
      throw new Error("expected a text with separator '::', got " + (rpr(key)));
    }
    protocol = R[0], path = R[1];
    if (!(protocol.length > 0)) {
      throw new Error("expected non-empty protocol, got key " + (rpr(key)));
    }
    if (!(path.length > 0)) {
      throw new Error("expected non-empty path, got key " + (rpr(key)));
    }

    /* ... more validations based on role ... */
    return R;
  };

  this._kind_and_command_from_fix = function(me, fix) {
    var command, kind, type;
    switch (type = CND.type_of(fix)) {
      case 'text':
        kind = 'text';
        command = fix;
        break;
      case 'list':
        kind = fix[0], command = 2 <= fix.length ? slice.call(fix, 1) : [];
        break;
      case 'pod':
        kind = fix.kind;
        command = Object.assign({}, fix);
        break;
      case 'function':
        kind = 'call';
        command = [fix];
        break;
      default:
        throw new Error("expected a text, a list, a function or a POD, got a " + type);
    }
    return [kind, command];
  };

  this.register_fix = function(me, cause, effect, fix) {
    var rc_key, relation;
    if (fix == null) {
      fix = null;
    }
    this.validate_key(me, 'cause', cause);
    this.validate_key(me, 'effect', effect);
    rc_key = this._get_cause_effect_key(me, cause, effect);
    relation = {
      cause: cause,
      effect: effect,
      fix: fix
    };
    me['fixes'][rc_key] = relation;
    LTSORT.add(me['graph'], cause, effect);
    return null;
  };

  this.register_alignment = function(me, kind, method) {
    me['aligners'][kind] = method;
    return null;
  };

  this.get_fix = function(me, cause, effect, fallback) {
    var R, rc_key;
    this.validate_key(me, 'cause', cause);
    this.validate_key(me, 'effect', effect);
    rc_key = this._get_cause_effect_key(me, cause, effect);
    if ((R = me['fixes'][rc_key]) == null) {
      if (fallback !== void 0) {
        return fallback;
      }
      throw new Error("no fix for " + (rpr(rc_key)));
    }
    return R;
  };

  this._get_cause_effect_key = function(me, cause, effect) {

    /* TAINT wrong way around */
    return effect + " -> " + cause;
  };

  this.stamp = function(me, key, handler) {
    var path, protocol, ref, stamper;
    ref = this.split_key(me, key), protocol = ref[0], path = ref[1];
    if ((stamper = me['monitors'][protocol]) == null) {
      return handler(new Error("no stamper for protocol " + (rpr(protocol))));
    }
    return stamper(me, path, handler);
  };

  this.get_boxed_chart = function(me) {
    var R, box, i, key, len, ref, target;
    R = [];
    ref = LTSORT.group(me['graph']);
    for (i = 0, len = ref.length; i < len; i++) {
      box = ref[i];
      target = [];
      R.push((function() {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = box.length; j < len1; j++) {
          key = box[j];
          results.push(key);
        }
        return results;
      })());
    }
    return R;
  };

  this.get_indexed_chart = function(me) {
    return this._indexed_from_boxed_series(me, this.get_boxed_chart(me));
  };

  this.fetch_boxed_trend = function(me, handler) {
    step((function(_this) {
      return function*(resume) {
        var Z, box, collector, i, j, k, key, len, len1, len2, ref, target, timestamp, timestamps;
        Z = [];
        collector = new Map();
        ref = _this.get_boxed_chart(me);
        for (i = 0, len = ref.length; i < len; i++) {
          box = ref[i];
          for (j = 0, len1 = box.length; j < len1; j++) {
            key = box[j];
            timestamp = (yield _this.stamp(me, key, resume));
            if (!CND.isa_number(timestamp)) {
              return handler(new Error("expected a number for timestamp of " + (rpr(key)) + ", got " + (rpr(timestamp))));
            }
            if ((target = collector.get(timestamp)) == null) {
              target = [];
              collector.set(timestamp, target);
            }
            target.push(key);
          }
        }
        timestamps = Array.from(collector.keys());
        timestamps.sort(function(a, b) {
          if (a > b) {
            return +1;
          }
          if (a < b) {
            return -1;
          }
          return 0;
        });
        for (k = 0, len2 = timestamps.length; k < len2; k++) {
          timestamp = timestamps[k];
          Z.push(collector.get(timestamp));
        }
        debug('30112', collector);
        debug('30112', timestamps);
        return handler(null, Z);
      };
    })(this));
    return null;
  };

  this.fetch_indexed_trend = function(me, handler) {
    step((function(_this) {
      return function*(resume) {
        var boxed_trend;
        boxed_trend = (yield _this.fetch_boxed_trend(me, resume));
        return handler(null, _this._indexed_from_boxed_series(me, boxed_trend));
      };
    })(this));
    return null;
  };

  this._indexed_from_boxed_series = function(me, boxed_series) {
    var R, box, box_idx, i, j, len, len1, name;
    R = {};
    for (box_idx = i = 0, len = boxed_series.length; i < len; box_idx = ++i) {
      box = boxed_series[box_idx];
      for (j = 0, len1 = box.length; j < len1; j++) {
        name = box[j];
        R[name] = box_idx;
      }
    }
    return R;
  };

  this._boxed_series_as_vertical_rpr = function(me, title, boxed_series) {
    var R, box, i, len;
    R = [];
    R.push('\n');
    R.push('│   ' + title);
    for (i = 0, len = boxed_series.length; i < len; i++) {
      box = boxed_series[i];
      R.push('├─  ' + box.join(' '));
    }
    R.push('▼');
    return R.join('\n');
  };

  this.find_first_fault = function(me, handler) {
    return this._find_faults(me, true, handler);
  };

  this.find_faults = function(me, handler) {
    return this._find_faults(me, false, handler);
  };

  this._find_faults = function(me, first_only, handler) {
    step((function(_this) {
      return function*(resume) {
        var R, boxed_chart, cmp_key, cmp_trend_idx, i, indexed_chart, indexed_trend, len, messages, ref, ref_chart_idx, ref_key, ref_trend_idx, relation, warn_missing;
        boxed_chart = _this.get_boxed_chart(me);
        indexed_chart = _this.get_indexed_chart(me);
        indexed_trend = (yield _this.fetch_indexed_trend(me, resume));
        R = first_only ? null : [];
        messages = {};
        warn_missing = function(name) {

          /* TAINT warn or fail? */
          var message;
          message = "not in trend: " + (rpr(ref_key));
          if (!(message in messages)) {
            warn(message);
          }
          messages[message] = 1;
          return null;
        };
        for (ref_key in indexed_chart) {
          ref_chart_idx = indexed_chart[ref_key];
          ref_trend_idx = indexed_trend[ref_key];
          if (ref_trend_idx == null) {
            warn_missing(ref_key);
            continue;
          }
          ref = me['graph']['precedents'].get(ref_key);
          for (i = 0, len = ref.length; i < len; i++) {
            cmp_key = ref[i];
            cmp_trend_idx = indexed_trend[cmp_key];
            if (cmp_trend_idx == null) {
              warn_missing(cmp_key);
              continue;
            }
            if (cmp_trend_idx < ref_trend_idx) {
              continue;
            }
            relation = _this.get_fix(me, cmp_key, ref_key, null);
            if (relation == null) {
              relation = {
                cause: comparison,
                effect: reference,
                fix: null
              };
            }
            relation = Object.assign({}, relation);
            if (first_only) {
              handler(null, relation);
              return null;
            }
            R.push(relation);
          }
        }
        handler(null, R);
        return null;
      };
    })(this));
    return null;
  };

  this.align = (function(_this) {
    return function(me, settings, handler) {
      var Z, arity, max_run_count, progress, ref, ref1, report, run_count, runs;
      if (settings == null) {
        settings = null;
      }
      switch (arity = arguments.length) {
        case 2:
          handler = settings;
          settings = null;
          break;
        case 3:
          null;
          break;
        default:
          throw new Error("expected 2 or 3 arguments, got " + arity);
      }
      report = (ref = settings != null ? settings['report'] : void 0) != null ? ref : false;
      progress = (ref1 = settings != null ? settings['progress'] : void 0) != null ? ref1 : false;
      runs = [];
      run_count = 0;
      Z = {
        runs: runs,
        t0: new Date()
      };
      max_run_count = (Object.keys(me['fixes'])).length * 2;
      step(function*(resume) {
        var cause, command, dt, effect, error, fault, fix, i, kind, len, method, output, ref2, run, run_idx, t0, t1;
        while ((fault = (yield _this.find_first_fault(me, resume))) != null) {
          run_count += +1;
          if (run_count > max_run_count) {
            return handler(new Error("suspecting runaway loop after " + run_count + " runs"), Z);
          }
          t0 = new Date();
          cause = fault.cause, effect = fault.effect, fix = fault.fix;
          try {
            ref2 = _this._kind_and_command_from_fix(me, fix), kind = ref2[0], command = ref2[1];
          } catch (error1) {
            error = error1;
            return handler(error);
          }
          if ((method = me['aligners'][kind]) != null) {
            if (progress) {
              urge(_this._boxed_series_as_vertical_rpr(me, 'trend', (yield _this.fetch_boxed_trend(me, resume))));
              whisper("align: run #" + (runs.length + 1) + " " + cause + " -> " + effect);
            }
            output = (yield method(me, command, resume));
            if (output == null) {
              output = null;
            }
          } else {
            return handler(new Error("unknown alignment: " + (rpr(kind))));
          }
          t1 = new Date();
          dt = (t1 - t0) / 1000;
          run = Object.assign({}, fault, {
            kind: kind,
            command: command,
            output: output,
            t0: t0,
            t1: t1,
            dt: dt
          });
          if (progress) {
            whisper("align: run #" + (runs.length + 1) + " " + cause + " -> " + effect + " completed after " + (dt.toFixed(3)) + "s");
          }
          runs.push(run);
        }
        Z['t1'] = new Date();
        Z['dt'] = (Z['t1'] - Z['t0']) / 1000;
        if (report) {
          for (run_idx = i = 0, len = runs.length; i < len; run_idx = ++i) {
            run = runs[run_idx];
            cause = run.cause, effect = run.effect, dt = run.dt, output = run.output;
            help("align: run #" + (run_idx + 1) + " " + cause + " -> " + effect + " completed after " + (dt.toFixed(3)) + "s");
          }
          help("align: took " + (Z['dt'].toFixed(3)) + "s");
        }
        return handler(null, Z);
      });
      return null;
    };
  })(this);

}).call(this);

//# sourceMappingURL=main.js.map
