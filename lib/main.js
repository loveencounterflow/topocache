// Generated by CoffeeScript 1.11.1
(function() {
  var $, $async, CND, D, LTSORT, PATH, alert, badge, debug, help, log, rpr, step, warn,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'TOPOCACHE/MAIN';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  alert = CND.get_logger('alert', badge);

  LTSORT = require('ltsort');

  step = require('coffeenode-suspend').step;

  PATH = require('path');

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  this.new_cache = function(settings) {
    var R, arity, home, ref, ref1, stamper, type;
    if (settings == null) {
      settings = null;
    }
    stamper = (ref = settings != null ? settings['stamper'] : void 0) != null ? ref : this.HELPERS.file_stamper;
    home = (ref1 = settings != null ? settings['home'] : void 0) != null ? ref1 : process.cwd();
    if ((type = CND.type_of(stamper)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    if ((arity = stamper.length) !== 3) {
      throw new Error("expected a function with arity 3, got one with arity " + arity);
    }
    R = {
      '~isa': 'TOPOCACHE/cache',
      'anchors': {},
      'fixes': {},
      'graph': LTSORT.new_graph({
        loners: false
      }),
      'home': home,
      'aligners': {},
      'stamper': stamper,
      'store': {}
    };
    this._reset_chart(R);
    return R;
  };

  this._reset_chart = function(me) {
    me['boxed-chart'] = null;
    me['indexed-chart'] = null;
    return null;
  };

  this._is_fresh = function(me) {
    return me['graph']['precedents'].size === 0;
  };

  this.register = function(me, cause, effect, fix) {
    var cause_json, effect_json, rc_key, relation;
    if (fix == null) {
      fix = null;
    }
    cause_json = JSON.stringify(cause);
    effect_json = JSON.stringify(effect);
    rc_key = this._get_cause_effect_key(me, cause_json, effect_json);
    relation = {
      cause: cause,
      effect: effect,
      fix: fix
    };
    me['fixes'][rc_key] = relation;
    LTSORT.add(me['graph'], cause_json, effect_json);
    this._reset_chart(me);
    return null;
  };

  this.register_alignment = function(me, kind, method) {
    me['aligners'][kind] = method;
    return null;
  };

  this.get_fix = function(me, cause, effect, fallback) {
    var R, cause_json, effect_json, rc_key;
    cause_json = JSON.stringify(cause);
    effect_json = JSON.stringify(effect);
    rc_key = this._get_cause_effect_key(me, cause_json, effect_json);
    if ((R = me['fixes'][rc_key]) == null) {
      if (fallback !== void 0) {
        return fallback;
      }
      throw new Error("no fix for " + (rpr(rc_key)));
    }
    return R;
  };

  this._get_cause_effect_key = function(me, cause_json, effect_json) {

    /* TAINT wrong way around */
    return effect_json + " -> " + cause_json;
  };

  this.get_boxed_chart = function(me) {
    var R, box, i, id_json, len, ref, target;
    if ((R = me['boxed-chart']) != null) {
      return R;
    }
    R = [];
    ref = LTSORT.group(me['graph']);
    for (i = 0, len = ref.length; i < len; i++) {
      box = ref[i];
      target = [];
      R.push((function() {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = box.length; j < len1; j++) {
          id_json = box[j];
          results.push(JSON.parse(id_json));
        }
        return results;
      })());
    }
    return me['boxed-chart'] = R;
  };

  this.get_indexed_chart = function(me) {
    var R;
    if ((R = me['indexed-chart']) != null) {
      return R;
    }
    return me['indexed-chart'] = this._indexed_from_boxed_series(me, this.get_boxed_chart(me));
  };

  this.fetch_boxed_trend = function(me, handler) {
    step((function(_this) {
      return function*(resume) {
        var Z, box, collector, i, id, j, k, len, len1, len2, ref, target, timestamp, timestamps;
        Z = [];
        collector = new Map();
        ref = _this.get_boxed_chart(me);
        for (i = 0, len = ref.length; i < len; i++) {
          box = ref[i];
          for (j = 0, len1 = box.length; j < len1; j++) {
            id = box[j];
            timestamp = (yield me['stamper'](me, id, resume));
            if (!CND.isa_number(timestamp)) {
              return handler(new Error("expected a number for timestamp of " + (rpr(id)) + ", got " + (rpr(timestamp))));
            }
            if ((target = collector.get(timestamp)) == null) {
              target = [];
              collector.set(timestamp, target);
            }
            target.push(id);
          }
        }
        timestamps = Array.from(collector.keys());
        timestamps.sort(function(a, b) {
          if (a > b) {
            return +1;
          }
          if (a < b) {
            return -1;
          }
          return 0;
        });
        for (k = 0, len2 = timestamps.length; k < len2; k++) {
          timestamp = timestamps[k];
          Z.push(collector.get(timestamp));
        }
        return handler(null, Z);
      };
    })(this));
    return null;
  };

  this.fetch_indexed_trend = function(me, handler) {
    step((function(_this) {
      return function*(resume) {
        var boxed_trend;
        boxed_trend = (yield _this.fetch_boxed_trend(me, resume));
        return handler(null, _this._indexed_from_boxed_series(me, boxed_trend));
      };
    })(this));
    return null;
  };

  this._indexed_from_boxed_series = function(me, boxed_series) {
    var R, box, box_idx, i, j, len, len1, name;
    R = {};
    for (box_idx = i = 0, len = boxed_series.length; i < len; box_idx = ++i) {
      box = boxed_series[box_idx];
      for (j = 0, len1 = box.length; j < len1; j++) {
        name = box[j];
        R[name] = box_idx;
      }
    }
    return R;
  };

  this.find_first_fault = function(me, handler) {
    return this._find_faults(me, true, handler);
  };

  this.find_faults = function(me, handler) {
    return this._find_faults(me, false, handler);
  };

  this._find_faults = function(me, first_only, handler) {
    step((function(_this) {
      return function*(resume) {
        var R, boxed_chart, cmp_name, cmp_name_json, cmp_trending_idx, i, indexed_chart, indexed_trend, len, messages, ref, ref_chart_idx, ref_name, ref_name_json, ref_trend_idx, relation, warn_missing;
        boxed_chart = _this.get_boxed_chart(me);
        indexed_chart = _this.get_indexed_chart(me);
        indexed_trend = (yield _this.fetch_indexed_trend(me, resume));
        R = first_only ? null : [];
        messages = {};
        warn_missing = function(name) {

          /* TAINT warn or fail? */
          var message;
          message = "not in trend: " + (rpr(ref_name));
          if (!(message in messages)) {
            warn(message);
          }
          messages[message] = 1;
          return null;
        };
        for (ref_name in indexed_chart) {
          ref_chart_idx = indexed_chart[ref_name];
          ref_trend_idx = indexed_trend[ref_name];
          if (ref_trend_idx == null) {
            warn_missing(ref_name);
            continue;
          }
          ref_name_json = JSON.stringify(ref_name);
          ref = me['graph']['precedents'].get(ref_name_json);
          for (i = 0, len = ref.length; i < len; i++) {
            cmp_name_json = ref[i];
            cmp_name = JSON.parse(cmp_name_json);
            cmp_trending_idx = indexed_trend[cmp_name];
            if (cmp_trending_idx == null) {
              warn_missing(cmp_name);
              continue;
            }
            if (cmp_trending_idx < ref_trend_idx) {
              continue;
            }
            relation = _this.get_fix(me, cmp_name, ref_name, null);
            if (relation == null) {
              relation = {
                cause: comparison,
                effect: reference,
                fix: null
              };
            }
            relation = Object.assign({}, relation);
            if (first_only) {
              handler(null, relation);
              return null;
            }
            R.push(relation);
          }
        }
        handler(null, R);
        return null;
      };
    })(this));
    return null;
  };

  this.HELPERS = {};

  this.HELPERS.file_stamper = (function(_this) {
    return function(me, path, handler) {
      return step(function*(resume) {
        var Z, error, locator, stat;
        locator = PATH.resolve(me['home'], path);
        try {
          stat = (yield (require('fs')).stat(locator, resume));
          Z = +stat['mtime'];
        } catch (error1) {
          error = error1;
          if (error['code'] !== 'ENOENT') {
            throw error;
          }

          /* TAINT use special value to signal file missing */
          Z = null;
        }
        return handler(null, Z);
      });
    };
  })(this);

  this.align = (function(_this) {
    return function(me, handler) {
      var max_run_count;
      max_run_count = (Object.keys(me['fixes'])).length * 2;
      step(function*(resume) {
        var Z, arity, command, dt, fault, fix, kind, method, output, run, runs, t0, t1, type;
        runs = [];
        Z = {
          runs: runs,
          t0: new Date()
        };
        while ((fault = (yield _this.find_first_fault(me, resume))) != null) {
          if (runs.length > max_run_count) {
            return handler(new Error("runaway loop?"), Z);
          }
          t0 = new Date();
          fix = fault.fix;
          switch (type = CND.type_of(fix)) {
            case 'text':
              kind = 'text';
              command = fix;
              break;
            case 'list':
              kind = fix[0], command = 2 <= fix.length ? slice.call(fix, 1) : [];
              break;
            case 'pod':
              kind = fix.kind;
              command = Object.assign({}, fix);
              break;
            default:
              type = CND.type_of(fix);
              return handler(new Error("expected a text, a list or a POD, got a " + type));
          }
          if ((method = me['aligners'][kind]) != null) {
            output = (yield method(me, command, resume));
          } else {
            switch (kind) {
              case 'shell':
                if ((arity = command.length !== 1)) {
                  throw new Error("expected single argument, got " + arity + " (" + (rpr(kind)) + ", " + (rpr(command)) + ")");
                }
                command = command[0];
                output = (yield _this.HELPERS.shell(me, command, resume));
                break;
              default:
                return handler(new Error("unknown kind of fix " + (rpr(kind))));
            }
          }
          t1 = new Date();
          dt = (t1 - t0) / 1000;
          run = {
            fault: fault,
            t0: t0,
            t1: t1,
            dt: dt,
            output: output
          };
          runs.push(run);
        }
        Z['t1'] = new Date();
        Z['dt'] = (Z['t1'] - Z['t0']) / 1000;
        return handler(null, Z);
      });
      return null;
    };
  })(this);

  this.HELPERS.shell = (function(_this) {
    return function(me, command, handler) {
      var type;
      switch (type = CND.type_of(command)) {
        case 'text':
          _this.HELPERS._shell_from_text(me, command, handler);
          break;
        case 'list':
          _this.HELPERS._shell_from_list(me, command, handler);
          break;
        default:
          handler(new Error("expected a list or a text, got a " + type));
      }
      return null;
    };
  })(this);

  this.HELPERS._shell_from_text = (function(_this) {
    return function(me, command, handler) {
      var settings;
      debug('87003', '_shell_from_text', rpr(command));

      /* TAINT keep output length limitation in mind */
      settings = {
        encoding: 'utf-8',
        cwd: me['home']
      };
      return (require('child_process')).exec(command, settings, function(error, stdout, stderr) {
        if (error != null) {
          return handler(error);
        }
        if ((stderr != null) && stderr.length > 0) {
          return handler(new Error(stderr));
        }
        return handler(null, stdout);
      });
    };
  })(this);

  this.HELPERS._shell_from_list = (function(_this) {
    return function(me, command, handler) {
      var cp, error_lines, output_lines, parameters, ref, settings;
      debug('87003', '_shell_from_list', rpr(command));
      ref = command, command = ref[0], parameters = 2 <= ref.length ? slice.call(ref, 1) : [];
      error_lines = [];
      output_lines = [];
      settings = {
        cwd: me['home']
      };
      cp = (require('child_process')).spawn(command, parameters, settings);
      cp.stdout.pipe(D.$split()).pipe($(function(line) {
        return output_lines.push(line);
      }));
      cp.stderr.pipe(D.$split()).pipe($(function(line) {
        return error_lines.push(line);
      }));
      cp.on('close', function(code) {
        var line, message;
        message = '';
        if (error_lines.length > 0) {
          message = ((function() {
            var i, len, results;
            results = [];
            for (i = 0, len = error_lines.length; i < len; i++) {
              line = error_lines[i];
              results.push(line);
            }
            return results;
          })()).join('\n');
        }
        if ((code !== 0) || (message.length > 0)) {
          if (message.length > 0) {
            message += '\n';
          }
          message += "command exited with code " + code + ": " + command + " " + (parameters.join(' '));
          alert(message);
          return handler(new Error(message));
        }
        return handler(null, output_lines.join('\n'));
      });
      return null;
    };
  })(this);

  this.HELPERS.touch = (function(_this) {
    return function(me, path, handler) {

      /* TAINT must properly escape path unless you know what you're doing */
      var locator;
      locator = PATH.resolve(me['home'], path);
      return _this.HELPERS.shell(me, "touch " + locator, handler);
    };
  })(this);

}).call(this);

//# sourceMappingURL=main.js.map
