// Generated by CoffeeScript 1.11.1
(function() {
  var CND, LTSORT, PATH, badge, debug, log, rpr, step;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'TOPOCACHE/MAIN';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  LTSORT = require('ltsort');

  step = require('coffeenode-suspend').step;

  PATH = require('path');

  this.new_cache = function(settings) {
    var R, arity, home, ref, ref1, stamper, type;
    if (settings == null) {
      settings = null;
    }
    stamper = (ref = settings != null ? settings['stamper'] : void 0) != null ? ref : this.HELPERS.file_stamper;
    home = (ref1 = settings != null ? settings['home'] : void 0) != null ? ref1 : process.cwd();
    if ((type = CND.type_of(stamper)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    if ((arity = stamper.length) !== 3) {
      throw new Error("expected a function with arity 3, got one with arity " + arity);
    }
    R = {
      '~isa': 'TOPOCACHE/cache',
      'graph': LTSORT.new_graph({
        loners: false
      }),
      'fixes': {},
      'store': {},
      'stamper': stamper,
      'home': home,
      'anchors': {}
    };
    this._reset_chart(R);
    this._reset_trend(R);
    return R;
  };

  this._reset_chart = function(me) {
    me['boxed-chart'] = null;
    me['indexed-chart'] = null;
    return me;
  };

  this._reset_trend = function(me) {
    me['boxed-trend'] = null;
    me['indexed-trend'] = null;
    return me;
  };

  this._is_fresh = function(me) {
    return me['graph']['precedents'].size === 0;
  };

  this.HELPERS = {};

  this.HELPERS.file_stamper = (function(_this) {
    return function(me, path, handler) {
      return step(function*(resume) {
        var Z, error, locator, stat;
        locator = PATH.resolve(me['home'], path);
        try {
          stat = (yield (require('fs')).stat(locator, resume));
          Z = +stat['mtime'];
        } catch (error1) {
          error = error1;
          if (error['code'] !== 'ENOENT') {
            throw error;
          }

          /* TAINT use special value to signal file missing */
          Z = null;
        }
        return handler(null, Z);
      });
    };
  })(this);

  this.HELPERS.shell = (function(_this) {
    return function(me, command, handler) {

      /* TAINT consider to use `spawn` so we get safe arguments */
      var settings;
      settings = {
        encoding: 'utf-8',
        cwd: me['home']
      };
      return (require('child_process')).exec(command, settings, function(error, stdout, stderr) {
        if (error != null) {
          return handler(error);
        }
        return handler(null, {
          stdout: stdout,
          stderr: stderr
        });
      });
    };
  })(this);

  this.HELPERS.touch = (function(_this) {
    return function(me, path, handler) {

      /* TAINT must properly escape path unless you know what you're doing */
      var locator;
      locator = PATH.resolve(me['home'], path);
      return _this.HELPERS.shell(me, "touch " + locator, handler);
    };
  })(this);

  this.register = function(me, cause, effect, fix) {
    var rc_key, type;
    if ((type = CND.type_of(cause)) !== 'text') {
      throw new Error("expected a text, got a " + type);
    }
    if ((type = CND.type_of(effect)) !== 'text') {
      throw new Error("expected a text, got a " + type);
    }
    if ((type = CND.type_of(fix)) !== 'text') {
      throw new Error("expected a text, got a " + type);
    }
    rc_key = this._get_rc_key(me, cause, effect);
    me['fixes'][rc_key] = fix;
    LTSORT.add(me['graph'], cause, effect);
    this._reset_chart(me);
    return null;
  };

  this.get_fix = function(me, cause, effect, fallback) {
    var R, rc_key, type;
    if ((type = CND.type_of(cause)) !== 'text') {
      throw new Error("expected a text, got a " + type);
    }
    if ((type = CND.type_of(effect)) !== 'text') {
      throw new Error("expected a text, got a " + type);
    }
    rc_key = this._get_rc_key(me, cause, effect);
    if ((R = me['fixes'][rc_key]) == null) {
      if (fallback === void 0) {
        throw new Error("no fix for " + (rpr(rc_key)));
      }
      R = fallback;
    }
    return R;
  };

  this._get_rc_key = function(me, cause, effect) {

    /* TAINT use URLs for RC keys? */
    return effect + " -> " + cause;
  };

  this.get_boxed_chart = function(me) {
    var R;
    if ((R = me['boxed-chart']) != null) {
      return R;
    }
    LTSORT.linearize(me['graph']);
    return me['boxed-chart'] = LTSORT.group(me['graph']);
  };

  this.get_indexed_chart = function(me) {
    var R;
    if ((R = me['indexed-chart']) != null) {
      return R;
    }
    return me['indexed-chart'] = this._indexed_from_boxed_series(me, this.get_boxed_chart(me));
  };

  this.fetch_boxed_trend = function(me, handler) {
    var Z;
    if ((Z = me['boxed-trend']) != null) {
      setImmediate(function() {
        return handler(null, Z);
      });
      return null;
    }
    step((function(_this) {
      return function*(resume) {
        var collector, i, id, len, ref, t;
        Z = [];
        collector = {};
        for (id in _this.get_indexed_chart(me)) {
          t = (yield me['stamper'](me, id, resume));
          if (!CND.isa_number(t)) {
            return handler(new Error("expected a number for timestamp of " + (rpr(id)) + ", got " + (rpr(t))));
          }
          (collector[t] != null ? collector[t] : collector[t] = []).push(id);
        }
        ref = (Object.keys(collector)).sort();
        for (i = 0, len = ref.length; i < len; i++) {
          t = ref[i];
          Z.push(collector[t]);
        }
        return handler(null, me['boxed-trend'] = Z);
      };
    })(this));
    return null;
  };

  this.fetch_indexed_trend = function(me, handler) {
    var Z;
    if ((Z = me['indexed-trend']) != null) {
      setImmediate(function() {
        return handler(null, Z);
      });
      return null;
    }
    step((function(_this) {
      return function*(resume) {
        var boxed_trend;
        boxed_trend = (yield _this.fetch_boxed_trend(me, resume));
        Z = me['indexed-trend'] = _this._indexed_from_boxed_series(me, boxed_trend);
        return handler(null, Z);
      };
    })(this));
    return null;
  };

  this._indexed_from_boxed_series = function(me, boxed_series) {
    var R, box, box_idx, i, j, len, len1, name;
    R = {};
    for (box_idx = i = 0, len = boxed_series.length; i < len; box_idx = ++i) {
      box = boxed_series[box_idx];
      for (j = 0, len1 = box.length; j < len1; j++) {
        name = box[j];
        R[name] = box_idx;
      }
    }
    return R;
  };

  this.find_first_fault = function(me, handler) {
    return this._find_faults(me, true, handler);
  };

  this.find_faults = function(me, handler) {
    return this._find_faults(me, false, handler);
  };

  this._find_faults = function(me, first_only, handler) {
    step((function(_this) {
      return function*(resume) {
        var R, cmp_charting_idx, cmp_name, cmp_trending_idx, entry, indexed_chart, indexed_trend, messages, ref_charting_idx, ref_name, ref_trending_idx, warn_missing;
        _this._reset_trend(me);
        indexed_chart = _this.get_indexed_chart(me);
        indexed_trend = (yield _this.fetch_indexed_trend(me, resume));
        R = first_only ? null : [];
        messages = {};
        warn_missing = function(name) {

          /* TAINT warn or fail? */
          var message;
          message = "not in trend: " + (rpr(ref_name));
          if (!(message in messages)) {
            warn(message);
          }
          messages[message] = 1;
          return null;
        };
        for (ref_name in indexed_chart) {
          ref_charting_idx = indexed_chart[ref_name];
          if ((ref_trending_idx = indexed_trend[ref_name]) == null) {
            warn_missing(ref_name);
            continue;
          }
          for (cmp_name in indexed_chart) {
            cmp_charting_idx = indexed_chart[cmp_name];

            /* Skip entries with same or smaller charting index (that do not depend on reference): */
            if (ref_charting_idx <= cmp_charting_idx) {
              continue;
            }
            if ((cmp_trending_idx = indexed_trend[cmp_name]) == null) {
              warn_missing(cmp_name);
              continue;
            }

            /* A fault is indicated by the trending index being in violation of the dependency relation
            as expressed by the charting index:
             */
            if (!(ref_trending_idx > cmp_trending_idx)) {
              entry = {
                reference: ref_name,
                comparison: cmp_name,
                fix: _this.get_fix(me, cmp_name, ref_name, null)
              };
              if (first_only) {
                handler(null, entry);
                return null;
              }
              R.push(entry);
            }
          }
        }
        handler(null, R);
        return null;
      };
    })(this));
    return null;
  };

}).call(this);

//# sourceMappingURL=main.js.map
