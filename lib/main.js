// Generated by CoffeeScript 1.11.1
(function() {
  var $, $async, CND, D, LTSORT, PATH, alert, badge, debug, get_monotimestamp, help, log, rpr, step, warn,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'TOPOCACHE/MAIN';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  alert = CND.get_logger('alert', badge);

  LTSORT = require('ltsort');

  PATH = require('path');

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  step = require('coffeenode-suspend').step;

  this.HELPERS = require('./helpers');

  this.STAMPERS = require('./stampers');

  this.ALIGNERS = require('./aligners');

  get_monotimestamp = require('./monotimestamp');

  this.new_cache = function(settings) {
    var R, aligners, home, ref, ref1, ref2, stampers;
    if (settings == null) {
      settings = null;
    }
    home = (ref = settings != null ? settings['home'] : void 0) != null ? ref : process.cwd();
    stampers = Object.assign({}, this.STAMPERS, (ref1 = settings != null ? settings['stampers'] : void 0) != null ? ref1 : null);
    aligners = Object.assign({}, this.ALIGNERS, (ref2 = settings != null ? settings['aligners'] : void 0) != null ? ref2 : null);
    R = {
      '~isa': 'TOPOCACHE/cache',
      'graph': LTSORT.new_graph({
        loners: false
      }),
      'home': home,
      'fixes': {},
      'aligners': aligners,
      'stampers': stampers,
      'store': {}
    };
    this._reset_chart(R);
    return R;
  };

  this._reset_chart = function(me) {
    me['boxed-chart'] = null;
    me['indexed-chart'] = null;
    return null;
  };

  this._is_fresh = function(me) {
    return me['graph']['precedents'].size === 0;
  };

  this._now = function() {
    return get_monotimestamp();
  };

  this.set = function(me, key, value, t0) {
    if (t0 == null) {
      t0 = null;
    }
    if (t0 == null) {
      t0 = this._now();
    }
    me['store'][key] = {
      t0: t0,
      key: key,
      value: value
    };
    return value;
  };

  this.get = function(me, key) {
    var ref;
    return (ref = me['store'][key]) != null ? ref['value'] : void 0;
  };

  this["delete"] = function(me, key) {
    return delete me['store'][key];
  };

  this.get_cache_entry = function(me, key) {
    return me['store'][key];
  };

  this.register_change = function(me, key, t0) {
    if (t0 == null) {
      t0 = null;
    }
    if (t0 == null) {
      t0 = this._now();
    }
    me['store'][key] = {
      t0: t0,
      key: key
    };
    return null;
  };

  this.validate_key = function(me, role, key) {
    this._split_key(me, role, key);
    return null;
  };

  this.split_key = function(me, key) {
    return this._split_key(me, null, key);
  };

  this._split_key = function(me, role, key) {
    var R, path, protocol, type;
    if ((type = CND.type_of(key)) !== 'text') {
      throw new Error("expected a text, got a " + type);
    }
    if ((R = key.split('::')).length !== 2) {
      throw new Error("expected a text with separator '::', got " + (rpr(key)));
    }
    protocol = R[0], path = R[1];
    if (!(protocol.length > 0)) {
      throw new Error("expected non-empty protocol, got key " + (rpr(key)));
    }
    if (!(path.length > 0)) {
      throw new Error("expected non-empty path, got key " + (rpr(key)));
    }

    /* ... more validations based on role ... */
    return R;
  };

  this._kind_and_command_from_fix = function(me, fix) {
    var command, kind, type;
    switch (type = CND.type_of(fix)) {
      case 'text':
        kind = 'text';
        command = fix;
        break;
      case 'list':
        kind = fix[0], command = 2 <= fix.length ? slice.call(fix, 1) : [];
        break;
      case 'pod':
        kind = fix.kind;
        command = Object.assign({}, fix);
        break;
      case 'function':
        kind = 'call';
        command = [fix];
        break;
      default:
        throw new Error("expected a text, a list, a function or a POD, got a " + type);
    }
    return [kind, command];
  };

  this.register_fix = function(me, cause, effect, fix) {
    var rc_key, relation;
    if (fix == null) {
      fix = null;
    }
    this.validate_key(me, 'cause', cause);
    this.validate_key(me, 'effect', effect);
    rc_key = this._get_cause_effect_key(me, cause, effect);
    relation = {
      cause: cause,
      effect: effect,
      fix: fix
    };
    me['fixes'][rc_key] = relation;
    LTSORT.add(me['graph'], cause, effect);
    this._reset_chart(me);
    return null;
  };

  this.register_alignment = function(me, kind, method) {
    me['aligners'][kind] = method;
    return null;
  };

  this.get_fix = function(me, cause, effect, fallback) {
    var R, rc_key;
    this.validate_key(me, 'cause', cause);
    this.validate_key(me, 'effect', effect);
    rc_key = this._get_cause_effect_key(me, cause, effect);
    if ((R = me['fixes'][rc_key]) == null) {
      if (fallback !== void 0) {
        return fallback;
      }
      throw new Error("no fix for " + (rpr(rc_key)));
    }
    return R;
  };

  this._get_cause_effect_key = function(me, cause, effect) {

    /* TAINT wrong way around */
    return effect + " -> " + cause;
  };

  this.stamp = function(me, key, handler) {
    var path, protocol, ref, stamper;
    ref = this.split_key(me, key), protocol = ref[0], path = ref[1];
    if ((stamper = me['stampers'][protocol]) == null) {
      return handler(new Error("no stamper for protocol " + (rpr(protocol))));
    }
    return stamper(me, path, handler);
  };

  this.get_boxed_chart = function(me) {
    var R, box, i, key, len, ref, target;
    if ((R = me['boxed-chart']) != null) {
      return R;
    }
    R = [];
    ref = LTSORT.group(me['graph']);
    for (i = 0, len = ref.length; i < len; i++) {
      box = ref[i];
      target = [];
      R.push((function() {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = box.length; j < len1; j++) {
          key = box[j];
          results.push(key);
        }
        return results;
      })());
    }
    return me['boxed-chart'] = R;
  };

  this.get_indexed_chart = function(me) {
    var R;
    if ((R = me['indexed-chart']) != null) {
      return R;
    }
    return me['indexed-chart'] = this._indexed_from_boxed_series(me, this.get_boxed_chart(me));
  };

  this.fetch_boxed_trend = function(me, handler) {
    step((function(_this) {
      return function*(resume) {
        var Z, box, collector, i, j, k, key, len, len1, len2, ref, target, timestamp, timestamps;
        Z = [];
        collector = new Map();
        ref = _this.get_boxed_chart(me);
        for (i = 0, len = ref.length; i < len; i++) {
          box = ref[i];
          for (j = 0, len1 = box.length; j < len1; j++) {
            key = box[j];
            timestamp = (yield _this.stamp(me, key, resume));
            if (!CND.isa_number(timestamp)) {
              return handler(new Error("expected a number for timestamp of " + (rpr(key)) + ", got " + (rpr(timestamp))));
            }
            if ((target = collector.get(timestamp)) == null) {
              target = [];
              collector.set(timestamp, target);
            }
            target.push(key);
          }
        }
        timestamps = Array.from(collector.keys());
        timestamps.sort(function(a, b) {
          if (a > b) {
            return +1;
          }
          if (a < b) {
            return -1;
          }
          return 0;
        });
        for (k = 0, len2 = timestamps.length; k < len2; k++) {
          timestamp = timestamps[k];
          Z.push(collector.get(timestamp));
        }
        return handler(null, Z);
      };
    })(this));
    return null;
  };

  this.fetch_indexed_trend = function(me, handler) {
    step((function(_this) {
      return function*(resume) {
        var boxed_trend;
        boxed_trend = (yield _this.fetch_boxed_trend(me, resume));
        return handler(null, _this._indexed_from_boxed_series(me, boxed_trend));
      };
    })(this));
    return null;
  };

  this._indexed_from_boxed_series = function(me, boxed_series) {
    var R, box, box_idx, i, j, len, len1, name;
    R = {};
    for (box_idx = i = 0, len = boxed_series.length; i < len; box_idx = ++i) {
      box = boxed_series[box_idx];
      for (j = 0, len1 = box.length; j < len1; j++) {
        name = box[j];
        R[name] = box_idx;
      }
    }
    return R;
  };

  this.find_first_fault = function(me, handler) {
    return this._find_faults(me, true, handler);
  };

  this.find_faults = function(me, handler) {
    return this._find_faults(me, false, handler);
  };

  this._find_faults = function(me, first_only, handler) {
    step((function(_this) {
      return function*(resume) {
        var R, boxed_chart, cmp_key, cmp_trend_idx, i, indexed_chart, indexed_trend, len, messages, ref, ref_chart_idx, ref_key, ref_trend_idx, relation, warn_missing;
        boxed_chart = _this.get_boxed_chart(me);
        indexed_chart = _this.get_indexed_chart(me);
        indexed_trend = (yield _this.fetch_indexed_trend(me, resume));
        R = first_only ? null : [];
        messages = {};
        warn_missing = function(name) {

          /* TAINT warn or fail? */
          var message;
          message = "not in trend: " + (rpr(ref_key));
          if (!(message in messages)) {
            warn(message);
          }
          messages[message] = 1;
          return null;
        };
        for (ref_key in indexed_chart) {
          ref_chart_idx = indexed_chart[ref_key];
          ref_trend_idx = indexed_trend[ref_key];
          if (ref_trend_idx == null) {
            warn_missing(ref_key);
            continue;
          }
          ref = me['graph']['precedents'].get(ref_key);
          for (i = 0, len = ref.length; i < len; i++) {
            cmp_key = ref[i];
            cmp_trend_idx = indexed_trend[cmp_key];
            if (cmp_trend_idx == null) {
              warn_missing(cmp_key);
              continue;
            }
            if (cmp_trend_idx < ref_trend_idx) {
              continue;
            }
            relation = _this.get_fix(me, cmp_key, ref_key, null);
            if (relation == null) {
              relation = {
                cause: comparison,
                effect: reference,
                fix: null
              };
            }
            relation = Object.assign({}, relation);
            if (first_only) {
              handler(null, relation);
              return null;
            }
            R.push(relation);
          }
        }
        handler(null, R);
        return null;
      };
    })(this));
    return null;
  };

  this.align = (function(_this) {
    return function(me, handler) {
      var max_run_count;
      max_run_count = (Object.keys(me['fixes'])).length * 2;
      step(function*(resume) {
        var Z, command, dt, error, fault, fix, kind, method, output, ref, run, runs, t0, t1;
        runs = [];
        Z = {
          runs: runs,
          t0: new Date()
        };
        while ((fault = (yield _this.find_first_fault(me, resume))) != null) {
          if (runs.length > max_run_count) {
            return handler(new Error("suspecting runaway loop after " + runs.length + " runs"), Z);
          }
          t0 = new Date();
          fix = fault.fix;
          try {
            ref = _this._kind_and_command_from_fix(me, fix), kind = ref[0], command = ref[1];
          } catch (error1) {
            error = error1;
            return handler(error);
          }
          if ((method = me['aligners'][kind]) != null) {
            output = (yield method(me, command, resume));
            if (output == null) {
              output = null;
            }
          } else {
            return handler(new Error("unknown alignment: " + (rpr(kind))));
          }
          t1 = new Date();
          dt = (t1 - t0) / 1000;
          run = Object.assign({}, fault, {
            kind: kind,
            command: command,
            output: output,
            t0: t0,
            t1: t1,
            dt: dt
          });
          runs.push(run);
        }
        Z['t1'] = new Date();
        Z['dt'] = (Z['t1'] - Z['t0']) / 1000;
        return handler(null, Z);
      });
      return null;
    };
  })(this);

}).call(this);

//# sourceMappingURL=main.js.map
