// Generated by CoffeeScript 1.11.1
(function() {
  var CND, COFFEESCRIPT, CP, FS, LTSORT, PATH, QUERYSTRING, URL, badge, debug, echo, help, info, log, rpr, stampers, step, urge, warn, whisper,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'TOPOCACHE/TESTS';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  LTSORT = require('ltsort');

  URL = require('url');

  QUERYSTRING = require('querystring');

  FS = require('fs');

  PATH = require('path');

  COFFEESCRIPT = require('coffee-script');

  CP = require('child_process');

  step = require('coffeenode-suspend').step;

  stampers = {
    file: {
      fetch_timestamp: (function(_this) {
        return function(path, handler) {
          return step(function*(resume) {
            var Z, error, stat;
            try {
              stat = (yield FS.stat(path, resume));
              Z = +stat['mtime'];
            } catch (error1) {
              error = error1;
              if (error['code'] !== 'ENOENT') {
                throw error;
              }

              /* TAINT use special value to signal file missing */
              Z = null;
            }
            return handler(null, Z);
          });
        };
      })(this)
    },
    coffee: {
      fix: (function(_this) {
        return function(cause_path, effect_path) {

          /* TAINT do we need sync & async fixing? signature? */
          var R, js_source;
          R = null;
          js_source = COFFEESCRIPT.compile(wrapped_source, {
            bare: false,
            filename: cause_path
          });
          return R;
        };
      })(this)
    }
  };

  this._shell = function(command, handler) {
    var settings;
    settings = {
      cwd: PATH.resolve(__dirname, '..'),
      encoding: 'utf-8'
    };
    return CP.exec(command, settings, function(error, stdout, stderr) {
      if (error != null) {
        return handler(error);
      }
      return handler(null, {
        stdout: stdout,
        stderr: stderr
      });
    });
  };

  this.new_cache = function() {
    var R;
    R = {
      '~isa': 'TOPOCACHE/cache',
      'graph': LTSORT.new_graph({
        loners: false
      }),
      'fixes': {},
      'store': {},
      'stampers': Object.assign({}, stampers),
      'anchors': {}
    };
    this._reset_chart(R);
    this._reset_trend(R);
    return R;
  };

  this._reset_chart = function(me) {
    me['boxed-chart'] = null;
    me['indexed-chart'] = null;
    return me;
  };

  this._reset_trend = function(me) {
    me['boxed-trend'] = null;
    me['indexed-trend'] = null;
    return me;
  };

  this._is_fresh = function(me) {
    return me['graph']['precedents'].size === 0;
  };

  this.register = function(me, cause, effect, fix) {
    var cause_url, effect_url, rc_key, ref, ref1;
    cause_url = CND.isa_list(cause) ? (ref = this.URL).join.apply(ref, [me].concat(slice.call(cause))) : cause;
    effect_url = CND.isa_list(effect) ? (ref1 = this.URL).join.apply(ref1, [me].concat(slice.call(effect))) : effect;
    rc_key = this._get_rc_key(me, cause_url, effect_url);
    me['fixes'][rc_key] = fix;
    LTSORT.add(me['graph'], cause_url, effect_url);
    this._reset_chart(me);
    return null;
  };

  this.get_fix = function(me, cause, effect, fallback) {
    var R, cause_url, effect_url, rc_key, ref, ref1;
    cause_url = CND.isa_list(cause) ? (ref = this.URL).join.apply(ref, [me].concat(slice.call(cause))) : cause;
    effect_url = CND.isa_list(effect) ? (ref1 = this.URL).join.apply(ref1, [me].concat(slice.call(effect))) : effect;
    rc_key = this._get_rc_key(me, cause_url, effect_url);
    if ((R = me['fixes'][rc_key]) == null) {
      if (fallback === void 0) {
        throw new Error("no fix for " + (rpr(rc_key)));
      }
      R = fallback;
    }
    return R;
  };

  this._get_rc_key = function(me, cause, effect) {

    /* TAINT use URLs for RC key as well */
    return effect + " -> " + cause;
  };

  this.URL = {};

  this.URL._get_relative_path = function(me, anchor, path) {
    return PATH.relative(anchor, PATH.resolve(anchor, path));
  };

  this.URL._get_absolute_path = function(me, anchor, path) {
    return PATH.resolve(anchor, path);
  };

  this.URL.from = (function(_this) {
    return function(me, x, y) {
      var ref, ref1, type;
      if ((x != null) && (y != null)) {
        return _this.URL.join(me, x, y);
      }
      if ((ref = (type = CND.type_of(x))) !== 'list' && ref !== 'text') {
        throw new Error("expected list or text, got a " + type);
      }
      if (type === 'list') {
        return (ref1 = _this.URL).join.apply(ref1, [me].concat(slice.call(x)));
      }
      if (_this.URL.is_url(me, x)) {
        return x;
      }
      return _this.URL.join(me, 'file', x);
    };
  })(this);

  this.URL.join = (function(_this) {
    return function(me, protocol, path) {
      var anchor, arity, type;
      if ((arity = arguments.length) !== 3) {
        throw new Error("expected 3 arguments, got " + arity);
      }
      if ((type = CND.type_of(protocol)) !== 'text') {
        throw new Error("expected a text, got a " + type);
      }
      if ((type = CND.type_of(path)) !== 'text') {
        throw new Error("expected a text, got a " + type);
      }
      if ((anchor = me['anchors'][protocol]) != null) {

        /* TAINT consider to use other methods for other protocols than `file` */
        path = PATH.relative(anchor, PATH.resolve(anchor, path));
      }
      return URL.format({
        protocol: protocol,
        slashes: true,
        pathname: path
      });
    };
  })(this);

  this.URL.split = (function(_this) {
    return function(me, url) {
      var R, path, protocol, ref;
      R = URL.parse(url, false, false);
      protocol = R['protocol'].replace(/:$/g, '');
      path = QUERYSTRING.unescape(R['pathname']);
      switch (protocol) {
        case 'file':
          path = PATH.resolve((ref = me['anchors'][protocol]) != null ? ref : '.', path);
      }
      return [protocol, path];
    };
  })(this);

  this.URL.set_anchor = (function(_this) {
    return function(me, protocol, anchor) {

      /* Anchors are reference points so you can use relative paths to files and web addresses. */
      if (anchor == null) {
        throw new Error("need anchor, got " + (rpr(anchor)));
      }
      if (me['anchors'][protocol] != null) {
        throw new Error("unable to reset anchor for protocol " + (rpr(protocol)));
      }
      if (!_this._is_fresh(me)) {
        throw new Error("unable to set anchor after adding dependency");
      }
      switch (protocol) {
        case 'file':
          me['anchors'][protocol] = anchor;
          break;
        default:
          throw new Error("unable to set anchor for protocol " + (rpr(protocol)));
      }
      return null;
    };
  })(this);

  this.URL.is_url = (function(_this) {
    return function(me, x) {
      if (!CND.isa_text(x)) {
        return false;
      }
      return /^[a-z]+:\/\//.test(x);
    };
  })(this);

  this.timestamp_from_url = function(me, url, handler) {

    /* TAINT use URLs as keys into info objects to avoid repeated parsing */
    var path, protocol, ref, stamper;
    ref = this.URL.split(me, url), protocol = ref[0], path = ref[1];
    stamper = me['stampers'][protocol];
    if (stamper == null) {
      return handler(new Error("no stamper for protocol " + (rpr(protocol))));
    }
    return stamper.fetch_timestamp(path, handler);
  };

  this.get_boxed_chart = function(me) {
    var R;
    if ((R = me['boxed-chart']) != null) {
      return R;
    }
    LTSORT.linearize(me['graph']);
    return me['boxed-chart'] = LTSORT.group(me['graph']);
  };

  this.get_indexed_chart = function(me) {
    var R;
    if ((R = me['indexed-chart']) != null) {
      return R;
    }
    return me['indexed-chart'] = this._indexed_from_boxed_series(me, this.get_boxed_chart(me));
  };

  this.fetch_boxed_trend = function(me, handler) {
    var Z;
    if ((Z = me['boxed-trend']) != null) {
      setImmediate(function() {
        return handler(null, Z);
      });
      return null;
    }
    step((function(_this) {
      return function*(resume) {
        var collector, i, len, ref, t, url;
        Z = [];
        collector = {};
        for (url in _this.get_indexed_chart(me)) {
          debug('30211', _this.get_indexed_chart(me));
          t = (yield _this.timestamp_from_url(me, url, resume));
          (collector[t] != null ? collector[t] : collector[t] = []).push(url);
        }
        ref = (Object.keys(collector)).sort();
        for (i = 0, len = ref.length; i < len; i++) {
          t = ref[i];
          Z.push(collector[t]);
        }
        return handler(null, me['boxed-trend'] = Z);
      };
    })(this));
    return null;
  };

  this.fetch_indexed_trend = function(me, handler) {
    var Z;
    if ((Z = me['indexed-trend']) != null) {
      setImmediate(function() {
        return handler(null, Z);
      });
      return null;
    }
    step((function(_this) {
      return function*(resume) {
        var boxed_trend;
        boxed_trend = (yield _this.fetch_boxed_trend(me, resume));
        Z = me['indexed-trend'] = _this._indexed_from_boxed_series(me, boxed_trend);
        return handler(null, Z);
      };
    })(this));
    return null;
  };

  this._indexed_from_boxed_series = function(me, boxed_series) {
    var R, box, box_idx, i, j, len, len1, name;
    R = {};
    for (box_idx = i = 0, len = boxed_series.length; i < len; box_idx = ++i) {
      box = boxed_series[box_idx];
      for (j = 0, len1 = box.length; j < len1; j++) {
        name = box[j];
        R[name] = box_idx;
      }
    }
    return R;
  };

  this.find_first_fault = function(me, handler) {
    return this._find_faults(me, true, handler);
  };

  this.find_faults = function(me, handler) {
    return this._find_faults(me, false, handler);
  };

  this._find_faults = function(me, first_only, handler) {
    step((function(_this) {
      return function*(resume) {
        var R, cmp_charting_idx, cmp_name, cmp_trending_idx, entry, indexed_chart, indexed_trend, messages, ref_charting_idx, ref_name, ref_trending_idx, warn_missing;
        _this._reset_trend(me);
        indexed_chart = _this.get_indexed_chart(me);
        indexed_trend = (yield _this.fetch_indexed_trend(me, resume));
        R = first_only ? null : [];
        messages = {};
        warn_missing = function(name) {

          /* TAINT warn or fail? */
          var message;
          message = "not in trend: " + (rpr(ref_name));
          if (!(message in messages)) {
            warn(message);
          }
          messages[message] = 1;
          return null;
        };
        for (ref_name in indexed_chart) {
          ref_charting_idx = indexed_chart[ref_name];
          if ((ref_trending_idx = indexed_trend[ref_name]) == null) {
            warn_missing(ref_name);
            continue;
          }
          for (cmp_name in indexed_chart) {
            cmp_charting_idx = indexed_chart[cmp_name];

            /* Skip entries with same or smaller charting index (that do not depend on reference): */
            if (ref_charting_idx <= cmp_charting_idx) {
              continue;
            }
            if ((cmp_trending_idx = indexed_trend[cmp_name]) == null) {
              warn_missing(cmp_name);
              continue;
            }

            /* A fault is indicated by the trending index being in violation of the dependency relation
            as expressed by the charting index:
             */
            if (!(ref_trending_idx > cmp_trending_idx)) {
              entry = {
                reference: ref_name,
                comparison: cmp_name,
                fix: _this.get_fix(me, cmp_name, ref_name, null)
              };
              if (first_only) {
                handler(null, entry);
                return null;
              }
              R.push(entry);
            }
          }
        }
        handler(null, R);
        return null;
      };
    })(this));
    return null;
  };

}).call(this);

//# sourceMappingURL=main.js.map
