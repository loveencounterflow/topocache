// Generated by CoffeeScript 1.11.1
(function() {
  var CND, CS, FS, LTSORT, PATH, QUERYSTRING, URL, badge, debug, echo, help, info, log, rpr, stampers, step, urge, warn, whisper,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'TOPOCACHE/TESTS';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  LTSORT = require('ltsort');

  URL = require('url');

  QUERYSTRING = require('querystring');

  FS = require('fs');

  PATH = require('path');

  CS = require('coffee-script');

  step = require('coffeenode-suspend').step;

  stampers = {
    file: {
      fetch_timestamp: (function(_this) {
        return function(path, handler) {
          return step(function*(resume) {
            var Z, error, stat;
            try {
              stat = (yield FS.stat(path, resume));
              Z = +stat['mtime'];
            } catch (error1) {
              error = error1;
              if (error['code'] !== 'ENOENT') {
                throw error;
              }

              /* TAINT use special value to signal file missing */
              Z = null;
            }
            return handler(null, Z);
          });
        };
      })(this)
    },
    coffee: {
      fix: (function(_this) {
        return function(precedent_path, consequent_path) {

          /* TAINT do we need sync & async fixing? signature? */
          var R, js_source;
          R = null;
          js_source = CS.compile(wrapped_source, {
            bare: false,
            filename: precedent_path
          });
          return R;
        };
      })(this)
    }
  };

  this.new_cache = function() {
    var R;
    R = {
      '~isa': 'TOPOCACHE/cache',
      'graph': LTSORT.new_graph({
        loners: false
      }),
      'fixes': {},
      'store': {},
      'stampers': Object.assign({}, stampers),
      'anchors': {}
    };
    this._reset_chart(R);
    this._reset_trend(R);
    this.URL.anchor(R, 'file');
    return R;
  };

  this._reset_chart = function(me) {
    me['boxed-chart'] = null;
    me['indexed-chart'] = null;
    return me;
  };

  this._reset_trend = function(me) {
    me['boxed-trend'] = null;
    me['indexed-trend'] = null;
    return me;
  };

  this.register = function(me, precedent, consequent, fix) {
    var consequent_url, precedent_url, rc_key, ref, ref1;
    precedent_url = CND.isa_list(precedent) ? (ref = this.URL).join.apply(ref, [me].concat(slice.call(precedent))) : precedent;
    consequent_url = CND.isa_list(consequent) ? (ref1 = this.URL).join.apply(ref1, [me].concat(slice.call(consequent))) : consequent;
    rc_key = this._get_rc_key(me, precedent_url, consequent_url);
    me['fixes'][rc_key] = fix;
    LTSORT.add(me['graph'], precedent_url, consequent_url);
    return this._reset_chart(me);
  };

  this.get_fix = function(me, precedent, consequent, fallback) {
    var R, consequent_url, precedent_url, rc_key, ref, ref1;
    precedent_url = CND.isa_list(precedent) ? (ref = this.URL).join.apply(ref, [me].concat(slice.call(precedent))) : precedent;
    consequent_url = CND.isa_list(consequent) ? (ref1 = this.URL).join.apply(ref1, [me].concat(slice.call(consequent))) : consequent;
    rc_key = this._get_rc_key(me, precedent_url, consequent_url);
    if ((R = me['fixes'][rc_key]) == null) {
      if (fallback === void 0) {
        throw new Error("no fix for " + (rpr(rc_key)));
      }
      R = fallback;
    }
    return R;
  };

  this._get_rc_key = function(me, precedent, consequent) {

    /* TAINT use URLs for RC key as well */
    return consequent + " -> " + precedent;
  };

  this.URL = {};

  this.URL.join = (function(_this) {
    return function(me, protocol, payload) {
      var anchor;
      if (payload == null) {
        payload = null;
      }
      if (payload == null) {
        payload = protocol;
        protocol = 'file';
      }
      if ((anchor = me['anchors'][protocol]) != null) {

        /* TAINT consider to use other methods for other protocols */

        /* TAINT consider to only use after testing for being a relative path */
        payload = PATH.resolve(anchor, payload);
      }
      return URL.format({
        protocol: protocol,
        slashes: true,
        pathname: payload
      });
    };
  })(this);

  this.URL.split = (function(_this) {
    return function(me, url) {
      var R, payload, protocol;
      R = URL.parse(url, false, false);
      protocol = R['protocol'].replace(/:$/g, '');
      payload = QUERYSTRING.unescape(R['pathname']);
      return [protocol, payload];
    };
  })(this);

  this.URL.anchor = (function(_this) {
    return function(me, protocol, path) {

      /* Anchors are reference points so you can use relative paths to files and web addresses. */
      switch (protocol) {
        case 'file':
          me['anchors'][protocol] = path != null ? path : process.cwd();
          break;
        default:
          throw new Error("uanble to set anchor for protocol " + (rpr(protocol)));
      }
      return null;
    };
  })(this);

  this.timestamp_from_url = function(me, url, handler) {
    var path, protocol, ref, stamper;
    ref = this.URL.split(me, url), protocol = ref[0], path = ref[1];
    stamper = me['stampers'][protocol];
    if (stamper == null) {
      return handler(new Error("no stamper for protocol " + (rpr(protocol))));
    }
    return stamper.fetch_timestamp(path, handler);
  };

  this.get_boxed_chart = function(me) {
    var R;
    if ((R = me['boxed-chart']) != null) {
      return R;
    }
    LTSORT.linearize(me['graph']);
    return me['boxed-chart'] = LTSORT.group(me['graph']);
  };

  this.get_indexed_chart = function(me) {
    var R;
    if ((R = me['indexed-chart']) != null) {
      return R;
    }
    return me['indexed-chart'] = this._indexed_from_boxed_series(me, this.get_boxed_chart(me));
  };

  this.fetch_boxed_trend = function(me, handler) {

    /* TAINT relies on FS */
    var Z;
    if ((Z = me['boxed-trend']) != null) {
      setImmediate(function() {
        return handler(null, Z);
      });
      return null;
    }
    step((function(_this) {
      return function*(resume) {
        var cache_entries, collector, entry, i, len, name, name1, ref, t;
        Z = [];
        collector = {};
        cache_entries = (yield FS.fetch_cache(resume));
        for (name in cache_entries) {
          entry = cache_entries[name];
          (collector[name1 = entry.t] != null ? collector[name1] : collector[name1] = []).push(name);
        }
        ref = (Object.keys(collector)).sort();
        for (i = 0, len = ref.length; i < len; i++) {
          t = ref[i];
          Z.push(collector[t]);
        }
        return handler(null, me['boxed-trend'] = Z);
      };
    })(this));
    return null;
  };

  this.fetch_indexed_trend = function(me, handler) {
    var Z;
    if ((Z = me['indexed-trend']) != null) {
      setImmediate(function() {
        return handler(null, Z);
      });
      return null;
    }
    step((function(_this) {
      return function*(resume) {
        var boxed_trend;
        boxed_trend = (yield _this.fetch_boxed_trend(me, resume));
        Z = me['indexed-trend'] = _this._indexed_from_boxed_series(me, boxed_trend);
        return handler(null, Z);
      };
    })(this));
    return null;
  };

  this._indexed_from_boxed_series = function(me, boxed_series) {
    var R, box, box_idx, i, j, len, len1, name;
    R = {};
    for (box_idx = i = 0, len = boxed_series.length; i < len; box_idx = ++i) {
      box = boxed_series[box_idx];
      for (j = 0, len1 = box.length; j < len1; j++) {
        name = box[j];
        R[name] = box_idx;
      }
    }
    return R;
  };

  this.find_first_fault = function(me, handler) {
    return this._find_faults(me, true, handler);
  };

  this.find_faults = function(me, handler) {
    return this._find_faults(me, false, handler);
  };

  this._find_faults = function(me, first_only, handler) {
    step((function(_this) {
      return function*(resume) {
        var R, cmp_charting_idx, cmp_name, cmp_trending_idx, entry, indexed_chart, indexed_trend, messages, ref_charting_idx, ref_name, ref_trending_idx, warn_missing;
        _this._reset_trend(me);
        indexed_chart = _this.get_indexed_chart(me);
        indexed_trend = (yield _this.fetch_indexed_trend(me, resume));
        R = first_only ? null : [];
        messages = {};
        warn_missing = function(name) {

          /* TAINT warn or fail? */
          var message;
          message = "not in trend: " + (rpr(ref_name));
          if (!(message in messages)) {
            warn(message);
          }
          messages[message] = 1;
          return null;
        };
        for (ref_name in indexed_chart) {
          ref_charting_idx = indexed_chart[ref_name];
          if ((ref_trending_idx = indexed_trend[ref_name]) == null) {
            warn_missing(ref_name);
            continue;
          }
          for (cmp_name in indexed_chart) {
            cmp_charting_idx = indexed_chart[cmp_name];

            /* Skip entries that have the same or smaller charting index (that are not depenedent on
            reference):
             */
            if (ref_charting_idx <= cmp_charting_idx) {
              continue;
            }
            if ((cmp_trending_idx = indexed_trend[cmp_name]) == null) {
              warn_missing(cmp_name);
              continue;
            }

            /* A fault is indicated by the trending index being in violation of the dependency relation
            as expressed by the charting index:
             */
            if (!(ref_trending_idx > cmp_trending_idx)) {
              entry = {
                reference: ref_name,
                comparison: cmp_name,
                fix: TC.get_fix(me, cmp_name, ref_name, null)
              };
              if (first_only) {
                handler(null, entry);
                return null;
              }
              R.push(entry);
            }
          }
        }
        handler(null, R);
        return null;
      };
    })(this));
    return null;
  };

}).call(this);

//# sourceMappingURL=main.js.map
