// Generated by CoffeeScript 1.11.1
(function() {
  var $, $async, CKD, CND, Crc32, D, PATH, TC, badge, debug, echo, error, get_monotimestamp, help, info, log, rpr, step, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'TOPOCACHE/FILEWATCHER';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  PATH = require('path');

  CKD = require('chokidar');

  get_monotimestamp = require('./monotimestamp');

  Crc32 = require('sse4_crc32');

  TC = require('./main');

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  step = require('coffeenode-suspend').step;

  this.main = function() {
    var path, watcher;
    watcher = CKD.watch();
    path = PATH.resolve(__dirname, '..', 'test-data');
    debug('99031', "file watcher: " + path);
    watcher.add(path);
    watcher.on('change', (function(_this) {
      return function(path, nfo) {
        return info(get_monotimestamp().toFixed(3), CND.steel('change:', path));
      };
    })(this));
    return null;
  };

  this.checksum_from_path = function(me, path, fallback, handler) {
    var arity, crc32, finished, input;
    switch (arity = arguments.length) {
      case 3:
        handler = fallback;
        fallback = void 0;
        break;
      case 4:
        null;
        break;
      default:
        throw new Error("expect 3 or 4 arguments, got " + arity);
    }
    crc32 = new Crc32.CRC32();
    finished = false;
    input = D.new_stream({
      path: path
    });
    input.on('error', function(error) {
      if (finished) {
        throw error;
      }
      finished = true;
      if (fallback !== void 0) {
        return handler(null, fallback);
      }
      return handler(error);
    });
    input.pipe($(function(data, send) {
      return crc32.update(data);
    })).pipe($('finish', (function(_this) {
      return function() {
        if (finished) {
          return;
        }
        finished = true;
        return handler(null, crc32.crc());
      };
    })(this)));
    return null;
  };

  this._get_crc = function(text) {
    return Crc32.calculate(text);
  };

  this.compile_catalog = function(me, handler) {
    var Z;
    Z = {};
    step((function(_this) {
      return function*(resume) {
        var checksum, i, len, locator, path, ref;
        ref = TC.get_file_paths(me);
        for (i = 0, len = ref.length; i < len; i++) {
          path = ref[i];
          locator = TC.locator_from_path(me, path);
          checksum = (yield _this.checksum_from_path(me, locator, 0, resume));
          Z[path] = {
            path: path,
            checksum: checksum
          };
        }
        return handler(null, Z);
      };
    })(this));
    return null;
  };

  this.$add_crc = function(me, fallback) {
    return $async((function(_this) {
      return function(nfo) {
        step(function*(resume) {
          var locator, path;
          path = nfo.path;
          locator = TC.locator_from_path(me, path);
          nfo['checksum'] = (yield _this.checksum_from_path(me, locator, fallback, resume));
          return null;
        });
        return null;
      };
    })(this));
  };

  this._default_catalog_home = PATH.resolve("/tmp/topocache-catalog-" + (this._get_crc(__dirname)));

  try {
    (require('fs')).mkdirSync(this._default_catalog_home);
  } catch (error1) {
    error = error1;
    if (error['code'] !== 'EEXIST') {
      throw error;
    }
  }

  this.main();

}).call(this);

//# sourceMappingURL=filewatcher.js.map
