// Generated by CoffeeScript 1.11.1
(function() {
  var stampers,
    slice = [].slice;

  stampers = {
    file: {
      fetch_timestamp: (function(_this) {
        return function(path, handler) {
          return step(function*(resume) {
            var Z, error, stat;
            try {
              stat = (yield FS.stat(path, resume));
              Z = +stat['mtime'];
            } catch (error1) {
              error = error1;
              if (error['code'] !== 'ENOENT') {
                throw error;
              }

              /* TAINT use special value to signal file missing */
              Z = null;
            }
            return handler(null, Z);
          });
        };
      })(this)
    },
    coffee: {
      fix: (function(_this) {
        return function(cause_path, effect_path) {

          /* TAINT do we need sync & async fixing? signature? */
          var R, js_source;
          R = null;
          js_source = COFFEESCRIPT.compile(wrapped_source, {
            bare: false,
            filename: cause_path
          });
          return R;
        };
      })(this)
    }
  };

  this.URL = {};

  this.URL._get_relative_path = function(me, anchor, path) {
    return PATH.relative(anchor, PATH.resolve(anchor, path));
  };

  this.URL._get_absolute_path = function(me, anchor, path) {
    return PATH.resolve(anchor, path);
  };

  this.URL.from = (function(_this) {
    return function(me, x, y) {
      var ref, ref1, type;
      if ((x != null) && (y != null)) {
        return _this.URL.join(me, x, y);
      }
      if ((ref = (type = CND.type_of(x))) !== 'list' && ref !== 'text') {
        throw new Error("expected list or text, got a " + type);
      }
      if (type === 'list') {
        return (ref1 = _this.URL).join.apply(ref1, [me].concat(slice.call(x)));
      }
      if (_this.URL.is_url(me, x)) {
        return x;
      }
      return _this.URL.join(me, 'file', x);
    };
  })(this);

  this.URL.join = (function(_this) {
    return function(me, protocol, path) {
      var anchor, arity, type;
      if ((arity = arguments.length) !== 3) {
        throw new Error("expected 3 arguments, got " + arity);
      }
      if ((type = CND.type_of(protocol)) !== 'text') {
        throw new Error("expected a text, got a " + type);
      }
      if ((type = CND.type_of(path)) !== 'text') {
        throw new Error("expected a text, got a " + type);
      }
      if ((anchor = me['anchors'][protocol]) != null) {

        /* TAINT consider to use other methods for other protocols than `file` */
        path = PATH.relative(anchor, PATH.resolve(anchor, path));
      }
      return URL.format({
        protocol: protocol,
        slashes: true,
        pathname: path
      });
    };
  })(this);

  this.URL.split = (function(_this) {
    return function(me, url) {
      var R, path, protocol, ref;
      R = URL.parse(url, false, false);
      protocol = R['protocol'].replace(/:$/g, '');
      path = QUERYSTRING.unescape(R['pathname']);
      switch (protocol) {
        case 'file':
          path = PATH.resolve((ref = me['anchors'][protocol]) != null ? ref : '.', path);
      }
      return [protocol, path];
    };
  })(this);

  this.URL.set_anchor = (function(_this) {
    return function(me, protocol, anchor) {

      /* Anchors are reference points so you can use relative paths to files and web addresses. */
      if (anchor == null) {
        throw new Error("need anchor, got " + (rpr(anchor)));
      }
      if (me['anchors'][protocol] != null) {
        throw new Error("unable to reset anchor for protocol " + (rpr(protocol)));
      }
      if (!_this._is_fresh(me)) {
        throw new Error("unable to set anchor after adding dependency");
      }
      switch (protocol) {
        case 'file':
          me['anchors'][protocol] = anchor;
          break;
        default:
          throw new Error("unable to set anchor for protocol " + (rpr(protocol)));
      }
      return null;
    };
  })(this);

  this.URL.is_url = (function(_this) {
    return function(me, x) {
      if (!CND.isa_text(x)) {
        return false;
      }
      return /^[a-z]+:\/\//.test(x);
    };
  })(this);

  this.timestamp_from_url = function(me, url, handler) {

    /* TAINT use URLs as keys into info objects to avoid repeated parsing */
    var path, protocol, ref, stamper;
    ref = this.URL.split(me, url), protocol = ref[0], path = ref[1];
    stamper = me['stampers'][protocol];
    if (stamper == null) {
      return handler(new Error("no stamper for protocol " + (rpr(protocol))));
    }
    return stamper.fetch_timestamp(path, handler);
  };

  this["can not set anchor after adding dependencies"] = function(T, done) {
    var g;
    g = TC.new_cache();
    TC.register(g, 'file:///test-data/f.coffee', 'file:///test-data/f.js', ['bash', 'coffee -c test-data']);
    T.throws("unable to set anchor after adding dependency", function() {
      return TC.URL.set_anchor(g, 'file', '/baz');
    });
    return done();
  };

  this["relative paths are roundtrip-invariant"] = function(T, done) {
    var anchor, g, i, is_absolute, len, path_1, path_2, probes, ref, rel_path;
    g = TC.new_cache();
    probes = [
      {
        anchor: '/somewhere',
        path_1: '/foo/bar/baz'
      }, {
        anchor: '/foo',
        path_1: '/foo/bar/baz'
      }, {
        anchor: '/baz',
        path_1: '/foo/bar/baz'
      }, {
        anchor: '/somewhere',
        path_1: 'foo/bar/baz'
      }, {
        anchor: '/foo',
        path_1: 'foo/bar/baz'
      }, {
        anchor: '/baz',
        path_1: 'foo/bar/baz'
      }
    ];
    for (i = 0, len = probes.length; i < len; i++) {
      ref = probes[i], anchor = ref.anchor, path_1 = ref.path_1;
      is_absolute = path_1.startsWith('/');
      rel_path = TC.URL._get_relative_path(null, anchor, path_1);
      path_2 = TC.URL._get_absolute_path(null, anchor, rel_path);
      if (!is_absolute) {
        path_2 = PATH.relative(anchor, path_2);
      }
      warn('77687', CND.red(path_1), CND.gold(anchor), CND.green(rel_path), CND.steel(path_2));
      T.eq(path_1, path_2);
    }
    return done();
  };

  this["file URLs are roundtrip-invariant"] = function(T, done) {
    var _, anchor, g, i, implicit_anchor, is_relative, len, matcher, path_1, path_2, probes, ref, ref1, url;
    implicit_anchor = PATH.resolve('.');
    probes = [
      {
        anchor: '/somewhere',
        path_1: 'foo'
      }, {
        anchor: '/somewhere',
        path_1: '/foo'
      }, {
        anchor: null,
        path_1: 'foo'
      }, {
        anchor: null,
        path_1: '/foo'
      }, {
        anchor: '/somewhere',
        path_1: '/foo/bar/baz'
      }, {
        anchor: '/foo',
        path_1: '/foo/bar/baz'
      }, {
        anchor: '/baz',
        path_1: '/foo/bar/baz'
      }, {
        anchor: '/somewhere',
        path_1: 'foo/bar/baz'
      }, {
        anchor: '/foo',
        path_1: 'foo/bar/baz'
      }, {
        anchor: '/baz',
        path_1: 'foo/bar/baz'
      }
    ];
    for (i = 0, len = probes.length; i < len; i++) {
      ref = probes[i], anchor = ref.anchor, path_1 = ref.path_1, matcher = ref.matcher;
      g = TC.new_cache();
      if (anchor != null) {
        TC.URL.set_anchor(g, 'file', anchor);
      }
      is_relative = !path_1.startsWith('/');
      url = TC.URL.join(g, 'file', path_1);
      ref1 = TC.URL.split(g, url), _ = ref1[0], path_2 = ref1[1];
      matcher = PATH.resolve(anchor != null ? anchor : implicit_anchor, path_1);
      warn('77687', CND.red(path_1), CND.gold(anchor), CND.green(url), CND.steel(path_2));
      T.eq(path_2, matcher);
    }
    return done();
  };

  this["only file URLs are relativized / absolutized"] = function(T, done) {
    var g, ref, ref1;
    g = TC.new_cache();
    if (typeof anchor !== "undefined" && anchor !== null) {
      TC.URL.set_anchor(g, 'file', anchor);
    }
    T.eq((ref = TC.URL).join.apply(ref, [g].concat(slice.call(['bash', 'coffee -c test-data']))), 'bash:///coffee -c test-data');
    T.eq(TC.URL.split(g, (ref1 = TC.URL).join.apply(ref1, [g].concat(slice.call(['bash', 'coffee -c test-data'])))), ['bash', 'coffee -c test-data']);
    return done();
  };

  this["URL.is_url"] = function(T, done) {
    var i, len, matcher, probe, probes_and_matchers, ref;
    probes_and_matchers = [[null, false], ['', false], [['file', 'foo/bar'], false], ['foo/bar', false], ['file://foo/bar', true], ['file:///foo/bar', true], ['file:///~foo/bar', true], ['http://languagelog.ldc.upenn.edu/nll/?p=28689', true]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
      urge(CND.white(rpr(probe)), CND.truth(TC.URL.is_url(null, probe)));
      T.eq(TC.URL.is_url(null, probe), matcher);
    }
    return done();
  };

  this["URL.from"] = function(T, done) {
    var g, i, len, matcher, probe, probes_and_matchers, ref, ref1;
    g = TC.new_cache();
    probes_and_matchers = [[[''], null], [[['file', 'foo/bar']], null], [[['http', 'domain.com/foo/bar']], null], [['foo/bar'], null], [['file://foo/bar'], null], [['file:///foo/bar'], null], [['file:///~foo/bar'], null], [['http://languagelog.ldc.upenn.edu/nll/?p=28689'], null]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
      urge(CND.white(rpr(probe)), CND.gold(rpr((ref1 = TC.URL).from.apply(ref1, [g].concat(slice.call(probe))))));
    }
    return done();
  };

}).call(this);

//# sourceMappingURL=_removed.js.map
