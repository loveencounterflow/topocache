// Generated by CoffeeScript 1.11.1
(function() {
  var $, $async, CND, D, MAIN, PATH, alert, badge, debug, help, log, rpr, step, warn,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'TOPOCACHE/HELPERS';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  alert = CND.get_logger('alert', badge);

  MAIN = require('./main');

  PATH = require('path');

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  step = require('coffeenode-suspend').step;

  this.shell = function(me, command, handler) {
    var type;
    switch (type = CND.type_of(command)) {
      case 'text':
        this._shell_from_command_text(me, command, handler);
        break;
      case 'list':
        this._shell_from_command_list(me, command, handler);
        break;
      default:
        handler(new Error("expected a list or a text, got a " + type));
    }
    return null;
  };

  this._shell_from_command_text = function(me, command, handler) {

    /* TAINT keep output length limitation in mind */
    var settings;
    settings = {
      encoding: 'utf-8',
      cwd: me['home']
    };
    return (require('child_process')).exec(command, settings, (function(_this) {
      return function(error, stdout, stderr) {
        if (error != null) {
          return handler(error);
        }
        if ((stderr != null) && stderr.length > 0) {
          return handler(new Error(stderr));
        }
        return handler(null, stdout);
      };
    })(this));
  };

  this._shell_from_command_list = function(me, command, handler) {
    var cp, error_lines, output_lines, parameters, ref, settings;
    ref = command, command = ref[0], parameters = 2 <= ref.length ? slice.call(ref, 1) : [];
    error_lines = [];
    output_lines = [];
    settings = {
      cwd: me['home']
    };
    cp = (require('child_process')).spawn(command, parameters, settings);
    cp.stdout.pipe(D.$split()).pipe($((function(_this) {
      return function(line) {
        return output_lines.push(line);
      };
    })(this)));
    cp.stderr.pipe(D.$split()).pipe($((function(_this) {
      return function(line) {
        return error_lines.push(line);
      };
    })(this)));
    cp.on('close', (function(_this) {
      return function(code) {
        var line, message;
        message = '';
        if (error_lines.length > 0) {
          message = ((function() {
            var i, len, results;
            results = [];
            for (i = 0, len = error_lines.length; i < len; i++) {
              line = error_lines[i];
              results.push(line);
            }
            return results;
          })()).join('\n');
        }
        if ((code !== 0) || (message.length > 0)) {
          if (message.length > 0) {
            message += '\n';
          }
          message += "command exited with code " + code + ": " + command + " " + (parameters.join(' '));
          alert(message);
          return handler(new Error(message));
        }
        return handler(null, output_lines.join('\n'));
      };
    })(this));
    return null;
  };

  this.touch = function(me, key, handler) {

    /* TAINT must properly escape path unless you know what you're doing */
    var locator, path, protocol, ref;
    ref = MAIN.split_key(me, key), protocol = ref[0], path = ref[1];
    if (protocol !== 'file') {
      throw new Error("unable to touch using protocol " + protocol);
    }
    locator = PATH.resolve(me['home'], path);
    return this.shell(me, "touch " + locator, handler);
  };

}).call(this);

//# sourceMappingURL=helpers.js.map
