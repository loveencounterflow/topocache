// Generated by CoffeeScript 1.11.1
(function() {
  var $, $async, CACHE, CND, D, FS, PATH, badge, debug, echo, get_read_sims_pipeline, get_read_variantusage_pipeline, help, info, log, read_sims, read_variantusage, rpr, step, test, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'TOPOCACHE/TOYTRAIN-DEMO';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  PATH = require('path');

  FS = require('fs');

  step = require('coffeenode-suspend').step;

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  require('pipedreams/lib/plugin-tsv');

  CACHE = require('./main');

  read_sims = function(S, version, handler) {
    var Z, input, path;
    if (version !== 'A' && version !== 'B') {
      throw new Error("unknown version " + (rpr(version)));
    }
    path = PATH.resolve(__dirname, '../test-data', 'sims.txt');
    input = D.new_stream({
      path: path
    });
    Z = null;
    whisper("reading " + path);
    input.pipe(D.new_stream({
      pipeline: get_read_sims_pipeline(S, version)
    })).pipe(D.$show()).pipe($(function(collector) {
      return Z = collector;
    })).pipe($('finish', function() {
      return handler(null, Z);
    }));
    return null;
  };

  read_variantusage = function(S, version, handler) {
    var Z, input, path;
    if (version !== 'A') {
      throw new Error("unknown version " + (rpr(version)));
    }
    path = PATH.resolve(__dirname, '../test-data', 'variants-and-usages.txt');
    input = D.new_stream({
      path: path
    });
    Z = null;
    whisper("reading " + path);
    input.pipe(D.new_stream({
      pipeline: get_read_variantusage_pipeline(S, version)
    })).pipe(D.$show()).pipe($(function(collector) {
      return Z = collector;
    })).pipe($('finish', function() {
      return handler(null, Z);
    }));
    return null;
  };

  get_read_sims_pipeline = function(S, version) {
    var R, Z;
    if (version !== 'A' && version !== 'B') {
      throw new Error("unknown version " + (rpr(version)));
    }
    Z = {};
    R = [];
    R.push(D.$split_tsv());
    R.push($(function(record, send) {

      /* discard extra fields */
      var _, source, target;
      _ = record[0], target = record[1], _ = record[2], source = record[3];
      return send([target, source]);
    }));
    if (version === 'B') {
      R.push($(function(record, send) {

        /* discard tags */
        var source, target;
        target = record[0], source = record[1];
        source = source.replace(/!.*$/g, '');
        return send([target, source]);
      }));
    }
    R.push($('null', function(record, send) {

      /* collect all records into single mapping */
      var source, target;
      if (record != null) {
        target = record[0], source = record[1];
        return Z[source] = target;
      } else {
        return send(Z);
      }
    }));
    return R;
  };

  get_read_variantusage_pipeline = function(S, version) {
    var R, Z, sims;
    if (version !== 'A') {
      throw new Error("unknown version " + (rpr(version)));
    }
    Z = {};
    R = [];
    sims = CACHE.get(S.cache, 'sims');
    debug('34322', sims);

    /*
    * unwrap line
    * split line at whitespace, resulting in multiple entries per line
    * separate each entry into CJK glyph, alphabetic usage letters
    * apply SIMs
    * discard duplicates as may have arisen from SIM application
    * de-duplify usagecodes
     */
    R.push(D.$split_tsv());
    R.push($(function(arg, send) {
      var line;
      line = arg[0];
      return send(line);
    }));
    R.push($(function(line, send) {
      return send(line.split(/\s+/));
    }));
    R.push($(function(entries, send) {
      var entry;
      return send((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = entries.length; i < len; i++) {
          entry = entries[i];
          results.push((entry.split(/([^a-zA-Z]+)/)).slice(1, 3));
        }
        return results;
      })());
    }));
    R.push($(function(record, send) {
      var i, idx, len, ref, source_glyph, target_glyph, usagecode;
      debug('34220-1', record);
      for (idx = i = 0, len = record.length; i < len; idx = ++i) {
        ref = record[idx], source_glyph = ref[0], usagecode = ref[1];
        target_glyph = sims[source_glyph];
        if (target_glyph == null) {
          continue;
        }
        record[idx][0] = target_glyph;
      }
      debug('34220-2', record);
      return send(record);
    }));
    R.push($(function(record, send) {
      var first_idx, glyph, i, idx_by_glyph, len, new_record, ref, usagecode;
      idx_by_glyph = {};
      new_record = [];
      for (i = 0, len = record.length; i < len; i++) {
        ref = record[i], glyph = ref[0], usagecode = ref[1];
        if ((first_idx = idx_by_glyph[glyph]) == null) {
          idx_by_glyph[glyph] = new_record.length;
          new_record.push([glyph, usagecode]);
        } else {
          new_record[first_idx][1] += usagecode;
        }
      }
      return send(new_record);
    }));
    R.push($(function(record, send) {
      var glyph, i, idx, len, letter, new_usagecode, ref, usagecode;
      for (idx = i = 0, len = record.length; i < len; idx = ++i) {
        ref = record[idx], glyph = ref[0], usagecode = ref[1];
        new_usagecode = (function() {
          var j, len1, ref1, results;
          ref1 = 'CJKTHM';
          results = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            letter = ref1[j];
            if (indexOf.call(usagecode, letter) >= 0) {
              results.push(letter);
            }
          }
          return results;
        })();
        record[idx][1] = new_usagecode.join('');
      }
      return send(record);
    }));
    return R;
  };

  module.exports = function(T, done) {
    step((function(_this) {
      return function*(resume) {
        var S, box, cause, cause_and_effect, effect, entry, f, fix, fixes, i, j, k, key, kind, len, len1, len2, ref, ref1, ref2, ref3, report, set_cache;
        _this._procure_test_files();
        S = {};
        set_cache = function() {
          var S, handler, i, key, method, parameters;
          S = arguments[0], key = arguments[1], method = arguments[2], parameters = 5 <= arguments.length ? slice.call(arguments, 3, i = arguments.length - 1) : (i = 3, []), handler = arguments[i++];
          step(function*(resume) {
            var result;
            whisper("retrieving data for " + key);
            result = (yield method.apply(null, slice.call(parameters).concat([resume])));
            CACHE.set(S.cache, key, result);
            handler();
            return null;
          });
          return null;
        };
        S.cache = CACHE.new_cache({
          home: PATH.resolve(__dirname, '../test-data')
        });
        info("stampers:", (Object.keys(S.cache['stampers'])).join(', '));
        info("aligners:", (Object.keys(S.cache['aligners'])).join(', '));
        fixes = [
          [
            'cache::base -> cache::sims', function(handler) {
              return set_cache(S, 'sims', read_sims, S, 'A', handler);
            }
          ], [
            'cache::sims -> cache::variantusage', function(handler) {
              return set_cache(S, 'variantusage', read_variantusage, S, 'A', handler);
            }
          ]
        ];
        for (i = 0, len = fixes.length; i < len; i++) {
          ref = fixes[i], cause_and_effect = ref[0], fix = ref[1];
          ref1 = cause_and_effect.split(/\s*->\s*/), cause = ref1[0], effect = ref1[1];
          CACHE.register_fix(S.cache, cause, effect, fix);
        }

        /* make this a topocache method */
        ref2 = (CACHE.get_boxed_chart(S.cache)).reverse();
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          box = ref2[j];
          for (k = 0, len2 = box.length; k < len2; k++) {
            entry = box[k];
            ref3 = entry.split('::'), kind = ref3[0], key = ref3[1];

            /* TAINT use `CACHE.touch` */
            if (kind !== 'cache') {
              continue;
            }
            debug(key, CACHE.set(S.cache, key, null));
          }
        }
        urge('chart:', CACHE._boxed_series_as_vertical_rpr(S.cache, 'chart', CACHE.get_boxed_chart(S.cache)));
        report = (yield CACHE.align(S.cache, {
          report: true,
          progress: true
        }, resume));
        f = function*() {
          var sim_count, sims, variantusage, variantusage_count;
          sims = (yield read_sims(S, 'A', resume));
          sim_count = (Object.keys(sims)).length;
          whisper("read " + sim_count + " SIMs");
          sims = (yield read_sims(S, 'B', resume));
          sim_count = (Object.keys(sims)).length;
          whisper("read " + sim_count + " SIMs");
          variantusage = (yield read_variantusage(S, 'A', resume));
          variantusage_count = (Object.keys(variantusage)).length;
          return whisper("read " + variantusage_count + " entries for variants & usages");
        };
        return done();
      };
    })(this));
    return null;
  };

}).call(this);

//# sourceMappingURL=toytrain-demo.js.map
